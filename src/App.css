import "./App.css";
import * as THREE from "three";
import { ARButton } from "three/examples/jsm/webxr/ARButton";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";

let camera, scene, renderer;
let controller;
let reticle;
let currentModel = null;
let models = [];
let loader;

let previousTouches = [];
let activeModel = null;
let isTranslating = false;
let isRotating = false;
let initialDistance = 0;
let currentScale = 1;

init();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  light.position.set(0.5, 1, 0.25);
  scene.add(light);

  loader = new GLTFLoader();
  const geometry = new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2);
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(geometry, material);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  scene.add(controller);

  let hitTestSourceRequested = false;
  let hitTestSource = null;

  renderer.setAnimationLoop(function (timestamp, frame) {
    if (frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();
      const session = renderer.xr.getSession();

      if (!hitTestSourceRequested) {
        session.requestReferenceSpace('viewer').then((refSpace) => {
          session.requestHitTestSource({ space: refSpace }).then((source) => {
            hitTestSource = source;
          });
        });

        session.addEventListener('end', () => {
          hitTestSourceRequested = false;
          hitTestSource = null;
        });

        hitTestSourceRequested = true;
      }

      if (hitTestSource) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
    }

    renderer.render(scene, camera);
  });

  // Gesture Events
  window.addEventListener("touchstart", onTouchStart);
  window.addEventListener("touchmove", onTouchMove);
  window.addEventListener("touchend", onTouchEnd);
}

function onTouchStart(event) {
  if (!activeModel) return;

  if (event.touches.length === 1) {
    isTranslating = true;
    previousTouches = [event.touches[0]];
  } else if (event.touches.length === 2) {
    isTranslating = false;
    isRotating = false;
    previousTouches = [...event.touches];
    initialDistance = getDistance(event.touches);
  }
}

function onTouchMove(event) {
  if (!activeModel) return;

  if (event.touches.length === 1 && isTranslating && previousTouches.length === 1) {
    const dx = event.touches[0].clientX - previousTouches[0].clientX;
    const dy = event.touches[0].clientY - previousTouches[0].clientY;

    activeModel.position.x += dx * 0.001;
    activeModel.position.z += dy * 0.001;

    // Optional: rotation swipe
    if (Math.abs(dx) > 20) {
      activeModel.rotation.y += dx * 0.005;
    }

    previousTouches = [event.touches[0]];
  }

  if (event.touches.length === 2) {
    const newDistance = getDistance(event.touches);
    const scaleChange = newDistance / initialDistance;
    currentScale *= scaleChange;
    activeModel.scale.set(currentScale, currentScale, currentScale);
    initialDistance = newDistance;

    // Move model using midpoint of two fingers
    const prevCenter = getMidpoint(previousTouches);
    const newCenter = getMidpoint(event.touches);
    const deltaX = (newCenter.x - prevCenter.x) * 0.001;
    const deltaZ = (newCenter.y - prevCenter.y) * 0.001;

    activeModel.position.x += deltaX;
    activeModel.position.z += deltaZ;

    previousTouches = [...event.touches];
  }
}

function onTouchEnd(event) {
  isTranslating = false;
  isRotating = false;
  previousTouches = [];
}

function getDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getMidpoint(touches) {
  return {
    x: (touches[0].clientX + touches[1].clientX) / 2,
    y: (touches[0].clientY + touches[1].clientY) / 2
  };
}

// Call this function to insert model
function loadModel(modelPath) {
  if (reticle.visible) {
    if (activeModel) {
      activeModel = null; // fix previous model
    }

    loader.load(modelPath, function (gltf) {
      const model = gltf.scene;
      model.position.setFromMatrixPosition(reticle.matrix);
      model.quaternion.setFromRotationMatrix(reticle.matrix);
      model.scale.set(0.2, 0.2, 0.2);
      scene.add(model);
      models.push(model);
      activeModel = model;
      currentScale = 1; // reset scale
    });
  }
}
